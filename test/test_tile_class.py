import os
import pickle
import shutil
import unittest
from typing import Dict, List, Tuple, Union

import numpy as np
from numpy.typing import NDArray
from paquo.classes import QuPathPathClass
from paquo.images import QuPathProjectImageEntry
from PIL.Image import Image
from shapely.geometry import Polygon
from shapely.geometry.base import BaseGeometry
from shapely.strtree import STRtree

from mothi.tiling_projects import QuPathTilingProject
from mothi.utils import label_img_to_polys

QUPATH_PATH: str = (
    "test_projects/qp_project/project.qpproj"  # generated by create_qp_project.ipynb
)
TEMPORARY_QP_PATH: str = "test_projects/temporary_project"
SLIDE_PATH: str = "test_projects/slides/white-4096.tif"
EXPECTED_MASK_PATH: str = "expected_masks.pkl"


class TestTileImportExportCicle(unittest.TestCase):
    """
    export, import in new project, then export to prove the circle outcome
    *QuPath drawn annoations*
    *no downsampling*
    """

    def setUp(self):
        self.qp_project: QuPathTilingProject = QuPathTilingProject(QUPATH_PATH, "r")
        self.temporary_project: QuPathTilingProject = QuPathTilingProject(
            TEMPORARY_QP_PATH, "x+"
        )
        self.temporary_project.add_image(SLIDE_PATH)
        self.temporary_project.update_path_classes(self.qp_project.path_classes)

    def test_import_export_cycle(self):
        first_export: NDArray[np.int32] = self.qp_project.get_tile_annot_mask(
            0, (10, 10), (450, 450)
        )
        self.temporary_project.save_mask_annotations(
            0, first_export, location=(1000, 1000)
        )
        second_export: NDArray[np.int32] = self.temporary_project.get_tile_annot_mask(
            0, (1000, 1000), (450, 450)
        )
        self.assertTrue(np.array_equal(first_export, second_export))

    def tearDown(self):
        # cleanup new QuPath project
        test_project_path: str = TEMPORARY_QP_PATH
        file: str
        for file in os.listdir(test_project_path):
            file_path: str = os.path.join(test_project_path, file)
            if os.path.isdir(file_path):
                shutil.rmtree(file_path)
            else:
                os.remove(file_path)


class TestTileExport(unittest.TestCase):
    """test export related functions"""

    def setUp(self):
        self.qp_project: QuPathTilingProject = QuPathTilingProject(
            path=QUPATH_PATH, mode="r"
        )
        self.qp_project.update_image_paths(try_relative=True)
        with open(EXPECTED_MASK_PATH, "rb") as mask_file:
            expected_masks = pickle.load(mask_file)
        self.expected_singlemask: NDArray[np.uint8] = expected_masks[0]
        self.expected_multimask: NDArray[np.uint8] = expected_masks[1]

    def test_get_tile(self):
        expected_tile: NDArray[np.int_] = (np.ones((50, 50, 3)) * 255).astype(np.int_)
        tile: Image = self.qp_project.get_tile(0, (500, 500), (50, 50))
        self.assertTrue(np.array_equal(expected_tile, np.asarray(tile).astype(np.int_)))
        tile_arr: NDArray[np.int_] = self.qp_project.get_tile(
            0, (500, 500), (50, 50), ret_array=True
        )
        self.assertTrue(np.array_equal(expected_tile, tile_arr))

    def test_get_tile_annot(self):
        # use custom annotation to know how the tiled annotation should look like
        expected_polygons: List[Polygon] = [
            Polygon([(510, 550), (550, 550), (550, 500), (510, 500)]),
            Polygon([(510, 510), (500, 510), (500, 550), (510, 550)]),
        ]
        tile_instersections: List[Tuple[Polygon, str]] = self.qp_project.get_tile_annot(
            0, (500, 500), (50, 50)
        )
        polys: List[Polygon] = [intersection[0] for intersection in tile_instersections]
        i: int
        poly: Polygon
        self.assertTrue(len(polys) == 2)
        for i, poly in enumerate(polys):
            self.assertTrue(poly.equals(expected_polygons[i]))

    def test_get_tile_annot_mask(self):
        single_mask: NDArray[np.int_] = self.qp_project.get_tile_annot_mask(
            0, (500, 500), (25, 25), downsample_level=1, multichannel=False
        )
        self.assertTrue(np.array_equal(self.expected_singlemask, single_mask))
        multi_mask: NDArray[np.int_] = self.qp_project.get_tile_annot_mask(
            0, (500, 500), (25, 25), downsample_level=1, multichannel=True
        )
        self.assertTrue(np.array_equal(self.expected_multimask, multi_mask))

    def tearDown(self):
        pass  # no files created


class TestTileImport(unittest.TestCase):
    """test import related functions"""

    def setUp(self):
        self.qp_project: QuPathTilingProject = QuPathTilingProject(
            path=QUPATH_PATH, mode="r"
        )
        self.temp_qp_project: QuPathTilingProject = QuPathTilingProject(
            TEMPORARY_QP_PATH, "x+"
        )
        self.temp_qp_project.add_image(SLIDE_PATH)
        self.temp_qp_project.update_path_classes(self.qp_project.path_classes)
        with open(EXPECTED_MASK_PATH, "rb") as mask_file:
            expected_masks = pickle.load(mask_file)
        self.expected_singlemask: NDArray[np.uint8] = expected_masks[0]
        self.expected_multimask: NDArray[np.uint8] = expected_masks[1]

    def test_label_img_to_polys(self):
        # check for correct polygons
        expected_polygons: List[Polygon] = [
            Polygon(
                [[10, 0], [10, 10], [10, 10], [10, 50], [50, 50], [50, 0], [10, 0]]
            ),
            Polygon([[0, 10], [0, 50], [10, 50], [10, 10], [0, 10]]),
        ]
        poly_with_class_single: List[Tuple[Union[Polygon, BaseGeometry], int]] = (
            label_img_to_polys(
                self.expected_singlemask, downsample_factor=2, multichannel=False
            )
        )
        self.assertTrue(len(poly_with_class_single) == 2)
        for i, (poly, _) in enumerate(poly_with_class_single):
            self.assertTrue(poly.simplify(0).equals(expected_polygons[i]))
        poly_with_class_multi = label_img_to_polys(
            self.expected_multimask, downsample_factor=2, multichannel=True
        )
        self.assertTrue(len(poly_with_class_multi) == 2)
        for i, (poly, _) in enumerate(poly_with_class_multi):
            self.assertTrue(poly.simplify(0).equals(expected_polygons[i]))

    def test_save_and_merge_annotations(self):
        # test by exporting two times size (25, 25), importing and merge those tiles,
        # export tile
        export_1: NDArray[np.int32] = self.qp_project.get_tile_annot_mask(
            0, (500, 500), (25, 25), downsample_level=1
        )
        export_2: NDArray[np.int32] = self.qp_project.get_tile_annot_mask(
            0, (500, 550), (25, 25), downsample_level=1
        )
        export_complete_area: NDArray[np.int_] = self.qp_project.get_tile_annot_mask(
            0, (500, 500), (25, 50), downsample_level=1
        )
        self.temp_qp_project.save_mask_annotations(
            0, export_1, location=(500, 500), downsample_level=1
        )
        self.temp_qp_project.save_mask_annotations(
            0, export_2, location=(500, 550), downsample_level=1
        )
        self.temp_qp_project.merge_near_annotations(0, max_dist=2)
        export_merged_area = self.temp_qp_project.get_tile_annot_mask(
            0, (500, 500), (25, 50), downsample_level=1
        )
        self.assertTrue(np.array_equal(export_complete_area, export_merged_area))

    def test_merge_near_annotations(self):
        # compare merged annoations to original annotations
        # no downsample!
        pass

    def tearDown(self) -> None:
        # cleanup new QuPath project
        test_project_path: str = TEMPORARY_QP_PATH
        file: str
        for file in os.listdir(test_project_path):
            file_path: str = os.path.join(test_project_path, file)
            if os.path.isdir(file_path):
                shutil.rmtree(file_path)
            else:
                os.remove(file_path)


class TestTileUtils(unittest.TestCase):
    """test util functions"""

    def setUp(self):
        self.white_image_id: int = 0
        self.qp_project: QuPathTilingProject = QuPathTilingProject(
            path=QUPATH_PATH, mode="r+"
        )
        self.white_image: QuPathProjectImageEntry = self.qp_project.images[
            self.white_image_id
        ]
        self.original_path_classes: Tuple[QuPathPathClass, ...] = (
            self.qp_project.path_classes
        )

    def test_update_path_classes(self):
        new_path_classes: Tuple[QuPathPathClass, ...] = (
            QuPathPathClass("classa"),
            QuPathPathClass("classb"),
            QuPathPathClass("classc"),
        )
        class_dict: Dict[int, QuPathPathClass] = {
            0: new_path_classes[0],
            1: new_path_classes[1],
            2: new_path_classes[2],
        }

        self.qp_project.path_classes = new_path_classes
        self.assertEqual(self.qp_project.path_classes, new_path_classes)
        self.assertEqual(self.qp_project._class_dict, class_dict)

    def test_update_img_annot_dict(self):
        # use own random annotations
        self.assertEqual(self.qp_project.img_annot_dict, {})
        self.qp_project._update_img_annot_dict(self.white_image_id)
        search_tree: STRtree
        search_tree_dict: Dict[int, Tuple[int, str]]
        search_tree, search_tree_dict = self.qp_project.img_annot_dict[
            self.white_image_id
        ]
        self.assertIsInstance(search_tree, STRtree)
        self.assertEqual(
            len(search_tree_dict),
            len(self.qp_project.images[self.white_image_id].hierarchy),
        )

    def tearDown(self):
        self.qp_project.path_classes = self.original_path_classes


if __name__ == "__main__":
    unittest.main()
