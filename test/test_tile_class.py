import unittest, os, shutil, pickle
from shapely.geometry import Polygon
import numpy as np
from shapely.strtree import STRtree

from qp_tiling.tile_class import QuPathOperations
from paquo.classes import QuPathPathClass

qupath_path = 'test_projects/qp_project/project.qpproj' # generated by create_qp_project.ipynb
temporary_qp_path = 'test_projects/temporary_project'
slide_path = 'test_projects/slides/white-4096.tif' 
expected_mask_path = 'expected_masks.pkl'


class TestTileImportExportCicle(unittest.TestCase):
    '''
    export, import in new project, then export to prove the circle outcome 
    *QuPath drawn annoations*
    *no downsampling*
    '''
    def setUp(self):
        self.qp_project = QuPathOperations(qupath_path, 'r')
        self.temporary_project = QuPathOperations(temporary_qp_path, 'x+')
        self.temporary_project.add_image(slide_path)
        self.temporary_project.update_path_classes(self.qp_project.path_classes)

    def test_import_export_cycle(self):
        first_export = self.qp_project.get_tile_annot_mask(0, (10,10), (450, 450))
        self.temporary_project.save_mask_annotations(0, first_export, location= (1000,1000))
        second_export = self.temporary_project.get_tile_annot_mask(0, (1000,1000), (450, 450))
        self.assertTrue(np.array_equal(first_export, second_export))
        
    def tearDown(self):
        # cleanup new QuPath project
        test_project_path = temporary_qp_path
        for file in os.listdir(test_project_path):
            file_path = os.path.join(test_project_path,file)
            if os.path.isdir(file_path):
                shutil.rmtree(file_path)
            else:
                os.remove(file_path)


class TestTileExport(unittest.TestCase):
    ''' test export related functions '''
    def setUp(self):
        self.qp_project = QuPathOperations(path = qupath_path, mode = 'r')
        self.qp_project.update_image_paths(try_relative = True)
        with open(expected_mask_path, 'rb') as mask_file:
            expected_masks = pickle.load(mask_file)
        self.expected_singlemask = expected_masks[0]
        self.expected_multimask = expected_masks[1] 

    def test_get_tile(self):
        expected_tile = np.ones((50, 50, 4)) * 255
        tile = self.qp_project.get_tile(0, (500, 500), (50, 50))
        self.assertTrue(np.array_equal(expected_tile, tile))
        
    def test_get_tile_annot(self):
        # use custom annotation to know how the tiled annotation should look like
        expected_polygons = [
            Polygon([(510, 550),
                     (550, 550),
                     (550, 500),
                     (510, 500)]),
            Polygon([(510, 510),
                     (500, 510),
                     (500, 550),
                     (510, 550)])
        ]
        tile_instersections = self.qp_project.get_tile_annot(0, (500, 500), (50, 50))
        polys = [intersection[1] for intersection in tile_instersections]
        for i, poly in enumerate(polys):
            self.assertTrue(poly.equals(expected_polygons[i]))

    def test_get_tile_annot_mask(self):
        single_mask = self.qp_project.get_tile_annot_mask(0, (500,  500),
                                                  (25, 25), downsample_level=1, 
                                                  multilabel=False)
        self.assertTrue(np.array_equal(self.expected_singlemask, single_mask))
        multi_mask = self.qp_project.get_tile_annot_mask(0, (500,  500),
                                                  (25, 25), downsample_level=1, 
                                                  multilabel=True)
        self.assertTrue(np.array_equal(self.expected_multimask, multi_mask))                                   

    def tearDown(self):
        pass # no files created


class TestTileImport(unittest.TestCase):
    ''' test import related functions '''
    def setUp(self):
        self.qp_project = QuPathOperations(path = qupath_path, mode = 'r')
        self.temp_qp_project = QuPathOperations(temporary_qp_path, 'x+')
        self.temp_qp_project.add_image(slide_path)
        self.temp_qp_project.update_path_classes(self.qp_project.path_classes)
        with open(expected_mask_path, 'rb') as mask_file:
            expected_masks = pickle.load(mask_file)
        self.expected_singlemask = expected_masks[0]
        self.expected_multimask = expected_masks[1] 

    def test_label_img_to_polys(self):
        # check for correct polygons
        expected_polygons = [
            Polygon([[10, 0],
                     [10, 10],
                     [10, 10],
                     [10, 50],
                     [50, 50],
                     [50, 0],
                     [10, 0]]),
            Polygon([[0, 10],
                     [0, 50],
                     [10, 50],
                     [10, 10],
                     [0, 10]])
        ]
        poly_with_class_single = self.temp_qp_project.label_img_to_polys(self.expected_singlemask,
                                               downsample_level= 1, 
                                               multilabel = False)
        for i, (poly, _) in enumerate(poly_with_class_single):
            self.assertTrue(poly.simplify(0).equals(expected_polygons[i]))
        poly_with_class_multi = self.temp_qp_project.label_img_to_polys(self.expected_singlemask,
                                               downsample_level= 1, 
                                               multilabel = True)
        for i, (poly, _) in enumerate(poly_with_class_multi):
            self.assertTrue(poly.simplify(0).equals(expected_polygons[i]))

    def test_save_and_merge_annotations(self):
        # test by exporting two times size (25, 25), importing and merge those tiles,
        # export tile
        export_1 = self.qp_project.get_tile_annot_mask(0, (500, 500), (25, 25), downsample_level=1)
        export_2 = self.qp_project.get_tile_annot_mask(0, (500, 550), (25, 25), downsample_level=1)
        export_complete_area = self.qp_project.get_tile_annot_mask(0, (500, 500), (25, 50), downsample_level = 1)
        self.temp_qp_project.save_mask_annotations(0, export_1, location = (500, 500), downsample_level = 1)
        self.temp_qp_project.save_mask_annotations(0, export_2, location = (500, 550), downsample_level = 1)
        self.temp_qp_project.merge_near_annotations(0, 2)
        export_merged_area = self.temp_qp_project.get_tile_annot_mask(0, (500, 500), (25, 50), downsample_level = 1)
        self.assertTrue(np.array_equal(export_complete_area, export_merged_area))

    def test_merge_near_annotations(self):
        # compare merged annoations to original annotations
        # no downsample!
        pass

    def tearDown(self) -> None:
        # cleanup new QuPath project
        test_project_path = temporary_qp_path
        for file in os.listdir(test_project_path):
            file_path = os.path.join(test_project_path,file)
            if os.path.isdir(file_path):
                shutil.rmtree(file_path)
            else:
                os.remove(file_path)


class TestTileUtils(unittest.TestCase):
    ''' test util functions '''
    def setUp(self):
        self.white_image_id = 0
        self.qp_project = QuPathOperations(path = qupath_path, mode = 'r+')
        self.white_image = self.qp_project.images[self.white_image_id]
        self.original_path_classes = self.qp_project.path_classes
    
    def test_update_path_classes(self):
        new_path_classes = (
            QuPathPathClass("classa"),
            QuPathPathClass("classb"),
            QuPathPathClass("classc")
        )
        class_dict = {
            0: new_path_classes[0],
            1: new_path_classes[1],
            2: new_path_classes[2],
        }

        self.qp_project.update_path_classes(new_path_classes)
        self.assertEqual(self.qp_project.path_classes, new_path_classes)
        self.assertEqual(self.qp_project._class_dict, class_dict)

    def test_update_img_annot_dict(self):
        # use own random annotations
        self.assertEqual(self.qp_project.img_annot_dict, {})
        self.qp_project.update_img_annot_dict(self.white_image_id)
        search_tree, search_tree_dict = self.qp_project.img_annot_dict[self.white_image_id]
        self.assertIsInstance(search_tree, STRtree)
        self.assertEqual(len(search_tree_dict),
                         len(self.qp_project.images[self.white_image_id].hierarchy))

    def tearDown(self):
        self.qp_project.path_classes = self.original_path_classes


if __name__ == '__main__':
    unittest.main()