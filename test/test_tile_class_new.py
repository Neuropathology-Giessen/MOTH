import unittest, os, shutil, pickle
import cv2
from shapely.geometry import Polygon
import numpy as np
import tifffile as tif
from shapely.strtree import STRtree

from qp_tiling.tile_class import QuPathOperations
from paquo.classes import QuPathPathClass

qupath_path = 'test_projects/qp_project/project.qpproj' # generated by create_qp_project.ipynb
temporary_qp_path = 'test_projects/temporary_project'
slide_path = 'test_projects/slides/white-5000.jpg' 


class TestTileImportExportCicle(unittest.TestCase):
    ''' test export, import in new project, then export to prove the circle outcome '''
    def setUp(self):
        self.qp_project = QuPathOperations(qupath_path, 'r')
        self.temporary_project = QuPathOperations(temporary_qp_path, 'x+')
        self.temporary_project.add_image(slide_path)
        self.temporary_project.update_path_classes(self.qp_project.path_classes)

    def test_import_export_cycle(self):
        first_export = self.qp_project.get_tile_annot_mask(0, (10,10), (450, 450))
        self.temporary_project.save_mask_annotations(0, first_export, location= (1000,1000))
        second_export = self.temporary_project.get_tile_annot_mask(0, (1000,1000), (450, 450))
        self.assertTrue(np.array_equal(first_export, second_export))
        
    def tearDown(self):
        # cleanup new QuPath project
        test_project_path = 'test_projects/temporary_project'
        for file in os.listdir(test_project_path):
            file_path = os.path.join(test_project_path,file)
            if os.path.isdir(file_path):
                shutil.rmtree(file_path)
            else:
                os.remove(file_path)


class TestTileExport(unittest.TestCase):
    ''' test export related functions '''
    def setUp(self):
        self.qp_project = QuPathOperations(path = qupath_path, mode = 'r')
        with open('expected_masks.pkl', 'rb') as mask_file:
            expected_masks = pickle.load(mask_file)
        self.expected_singlemask = expected_masks[0]
        self.expected_multimask = expected_masks[1] 

    def test_get_tile(self):
        pass # OpenSlide test
        
    def test_get_tile_annot(self):
        # use custom annotation to know how the tiled annotation should look like
        expected_polygons = [
            Polygon([(510, 550),
                     (550, 550),
                     (550, 500),
                     (510, 500)]),
            Polygon([(510, 510),
                     (500, 510),
                     (500, 550),
                     (510, 550)])
        ]
        tile_instersections = self.qp_project.get_tile_annot(0, (500, 500), (50, 50))
        polys = [intersection[1] for intersection in tile_instersections]
        for i, poly in enumerate(polys):
            self.assertTrue(poly.equals(expected_polygons[i]))

    def test_get_tile_annot_mask(self):
        single_mask = self.qp_project.get_tile_annot_mask(0, (500,  500),
                                                  (25, 25), downsample_level=1, 
                                                  multilabel=False)
        self.assertTrue(np.array_equal(self.expected_singlemask, single_mask))
        multi_mask = self.qp_project.get_tile_annot_mask(0, (500,  500),
                                                  (25, 25), downsample_level=1, 
                                                  multilabel=True)
        self.assertTrue(np.array_equal(self.expected_multimask, multi_mask))                                   

    def tearDown(self):
        pass


class TestTileImport(unittest.TestCase):
    ''' test import related functions '''
    def setUp(self):
        self.qp_project = QuPathOperations(path = qupath_path, mode = 'r+')
        self.import_image_path = 'qp_project/tiles/white/whole/white-background-500x500/white-background-500x500 [x=0,y=0,w=499,h=499].png'
        self.import_image = cv2.imread(self.import_image_path)[:,:,0]
        self.import_image = self.import_image / 255 * 15
        self.new_qp_project = QuPathOperations('qp_project/test_project_folder/', 'x+')
        self.new_qp_project.add_image('qp_project/Slides zum Training/white-background-500x500.jpg')
        self.new_qp_project.update_path_classes(self.qp_project.path_classes)

    def test_label_img_to_polys(self):
        # check for correct polygons
        pass
    
    def test_save_mask_annotations(self):
        # test by exporting (import_image), importing and then exporting mask
        # first export and second export must be equal
        self.new_qp_project.save_mask_annotations(0, self.import_image)
        exported = self.new_qp_project.get_tile_annot_mask(0, (0, 0), (499, 499))
        

    def test_merge_near_annotations(self):
        # compare merged annoations to original annotations
        # no downsample!
        pass

    def tearDown(self) -> None:
        # cleanup new QuPath project
        test_project_path = 'qp_project/test_project_folder'
        for file in os.listdir(test_project_path):
            file_path = os.path.join(test_project_path,file)
            if os.path.isdir(file_path):
                shutil.rmtree(file_path)
            else:
                os.remove(file_path)


class TestTileUtils(unittest.TestCase):
    ''' test util functions '''
    def setUp(self):
        self.white_image_id = 10
        self.qp_project = QuPathOperations(path = qupath_path, mode = 'r+')
        self.white_image = self.qp_project.images[self.white_image_id]
        self.original_path_classes = self.qp_project.path_classes
    
    def test_update_path_classes(self):
        new_path_classes = (
            QuPathPathClass("class1"),
            QuPathPathClass("class2"),
            QuPathPathClass("class3")
        )
        class_dict = {
            0: new_path_classes[0],
            1: new_path_classes[1],
            2: new_path_classes[2],
        }

        self.qp_project.update_path_classes(new_path_classes)
        self.assertEqual(self.qp_project.path_classes, new_path_classes)
        self.assertEqual(self.qp_project._class_dict, class_dict)

    def test_update_img_annot_dict(self):
        # use own random annotations
        self.assertEqual(self.qp_project.img_annot_dict, {})
        self.qp_project.update_img_annot_dict(self.white_image_id)
        search_tree, search_tree_dict = self.qp_project.img_annot_dict[self.white_image_id]
        self.assertIsInstance(search_tree, STRtree)
        self.assertEqual(len(search_tree_dict),
                         len(self.qp_project.images[self.white_image_id].hierarchy))

    def tearDown(self):
        self.qp_project.path_classes = self.original_path_classes


def suite():
    suite = unittest.TestSuite()
    suite.addTest(TestTileExport('test_get_tile_annot_mask'))

    return suite


if __name__ == '__main__':
    runner = unittest.TextTestRunner()
    runner.run(suite())
    # unittest.main()